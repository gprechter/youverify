%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}




\title{YouVerify}
\date{Dec 09, 2021}
\release{1.0}
\author{Griffin Prechter}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}

\index{module@\spxentry{module}!State@\spxentry{State}}\index{State@\spxentry{State}!module@\spxentry{module}}\index{State (class in State)@\spxentry{State}\spxextra{class in State}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:State.State}}\pysigline{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{State.}}\sphinxbfcode{\sphinxupquote{State}}}
\sphinxAtStartPar
Abstract class template for a representation of State in \sphinxstyleemphasis{YouVerify}.
\index{advance\_pc() (State.State method)@\spxentry{advance\_pc()}\spxextra{State.State method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:State.State.advance_pc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{advance\_pc}}}{\emph{\DUrole{n}{i}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{}~\begin{quote}

\sphinxAtStartPar
This abstract method is invoked when the framework wants to advance the program counter.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{i}} \textendash{} The number of statements to advance through.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{assume() (State.State method)@\spxentry{assume()}\spxextra{State.State method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:State.State.assume}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{assume}}}{\emph{\DUrole{n}{cond}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{object}}}{}~\begin{quote}

\sphinxAtStartPar
This abstract method is invoked when the framework wants to add an assumption to the current state.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cond}} \textendash{} The condition to be affixed to the path constraint.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{conditional\_branch() (State.State method)@\spxentry{conditional\_branch()}\spxextra{State.State method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:State.State.conditional_branch}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{conditional\_branch}}}{\emph{\DUrole{n}{cond}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{object}}, \emph{\DUrole{n}{destination}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{}~\begin{quote}

\sphinxAtStartPar
This abstract method is invoked when the framework reaches a conditional branching statement. Here,
a developer would likely want to implement state splitting.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cond}} \textendash{} The condition guarding the branch.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{destination}} \textendash{} The destination program counter for the branch.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{current\_statement (State.State property)@\spxentry{current\_statement}\spxextra{State.State property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:State.State.current_statement}}\pysigline{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{  }property\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{current\_statement}}}~\begin{quote}

\sphinxAtStartPar
This abstract property is invoked to retrieve the next statement to be executed by
the symbolic interpreter.
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
The next \sphinxcode{\sphinxupquote{Statement}} object to be \sphinxstyleemphasis{executed}.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
Statement

\end{description}\end{quote}

\end{fulllineitems}

\index{jump() (State.State method)@\spxentry{jump()}\spxextra{State.State method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:State.State.jump}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{jump}}}{\emph{\DUrole{n}{destination}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{}~\begin{quote}

\sphinxAtStartPar
This abstract method is invoked when the framework reaches an unconditional branching statement.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{destination}} \textendash{} The destination program counter for the branch.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_variable() (State.State method)@\spxentry{load\_variable()}\spxextra{State.State method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:State.State.load_variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{load\_variable}}}{\emph{\DUrole{n}{var}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{}~\begin{quote}

\sphinxAtStartPar
This abstract method is invoked when an identifier is evaluated and a variable is
to be fetched from the stateâ€™s variable store.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{var}} \textendash{} The identifier of the variable that will be retrieved.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The value of the variable that was retrieved.

\end{description}\end{quote}

\end{fulllineitems}

\index{store\_variable() (State.State method)@\spxentry{store\_variable()}\spxextra{State.State method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:State.State.store_variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{store\_variable}}}{\emph{\DUrole{n}{var}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}, \emph{\DUrole{n}{val}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{object}}}{}~\begin{quote}

\sphinxAtStartPar
This abstract method is invoked when the framework wants to assign a value to a variable.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{var}} \textendash{} The identifier of the variable being assigned to.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{val}} \textendash{} The value to be assigned to the variable.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_state() (State.State method)@\spxentry{update\_state()}\spxextra{State.State method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:State.State.update_state}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{update\_state}}}{}{}~\begin{quote}

\sphinxAtStartPar
This abstract method is invoked by the framework when before the next
statement is to be executed. This gives the \sphinxcode{\sphinxupquote{State}} object the opportunity
to modify the backend and setup for the next
statement execution. A developer would modify this to change
how the paths of a program are explored and how state is handled.
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{True}} if there is more state to be executed, \sphinxcode{\sphinxupquote{False}} otherwise.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{index:module-Wrappers}}\index{module@\spxentry{module}!Wrappers@\spxentry{Wrappers}}\index{Wrappers@\spxentry{Wrappers}!module@\spxentry{module}}\index{unary\_operator\_wrapper() (in module Wrappers)@\spxentry{unary\_operator\_wrapper()}\spxextra{in module Wrappers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Wrappers.unary_operator_wrapper}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Wrappers.}}\sphinxbfcode{\sphinxupquote{unary\_operator\_wrapper}}}{\emph{\DUrole{n}{f}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{function}}}{}~\begin{quote}

\sphinxAtStartPar
The wrapper takes in the original unary operator as its parameter and
optionally returns a new function with the new behavior.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} The unary function to be wrapped.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A new unary function.

\end{description}\end{quote}

\end{fulllineitems}

\index{binary\_operator\_wrapper() (in module Wrappers)@\spxentry{binary\_operator\_wrapper()}\spxextra{in module Wrappers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Wrappers.binary_operator_wrapper}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Wrappers.}}\sphinxbfcode{\sphinxupquote{binary\_operator\_wrapper}}}{\emph{\DUrole{n}{f}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{function}}}{}~\begin{quote}

\sphinxAtStartPar
The wrapper takes in the original binary operator as its parameter and
optionally returns a new function with the new behavior.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} The binary function to be wrapped.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A new binary function.

\end{description}\end{quote}

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{s}
\item\relax\sphinxstyleindexentry{State}\sphinxstyleindexpageref{index:\detokenize{module-State}}
\indexspace
\bigletter{w}
\item\relax\sphinxstyleindexentry{Wrappers}\sphinxstyleindexpageref{index:\detokenize{module-Wrappers}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}